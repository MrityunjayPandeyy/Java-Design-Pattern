# Creational Design Pattern
# Ensures that only one object of its kind exists and provides a single point of access to it for any other code.
## Single thread -> add a method in class to getInstance and check if instance is not existing then create a new instance and return else return the old one.

## multi-thread -> Multiple threads can call the creation method simultaneously and get several instances of Singleton class. ->
# Thread Safe with lazy loading


# questions :
1. How many ways you can write Singleton Class in Java?
   1. Singleton by synchronizing getInstance() method
   2. Singleton with public static final field initialized during class loading.
   3. Singleton generated by static nested class, also referred as Singleton holder pattern.
   4. From Java 5 on-wards using Enums


Read more: https://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html#ixzz8YQzu6fln
2. Why Enum Singletons are better in Java?
3. checked locking, volatile variable and lazy loading
4. Is it better to make whole getInstance() method synchronized or just critical section is enough? Which one you will prefer?
   1. This is related to double checked locking pattern, well synchronization is costly and when you apply this on whole method than call to getInstance() will be synchronized and contented.
   2.  Since synchronization is only needed during initialization on singleton instance, to prevent creating another instance of Singleton, Itâ€™s better to only synchronize critical section and not whole method. Singleton pattern is also closely related to factory design pattern where getInstance() serves as static factory method.
5.  What is lazy and early loading of Singleton and how will you implement it?
    1.  As there are many ways to implement Singleton like using double checked locking or Singleton class with static final instance initialized during class loading. Former is called lazy loading because Singleton instance is created only when client calls getInstance() method while later is called early loading because Singleton instance is created when class is loaded into memory.
6.  What is double checked locking in Singleton?
    1.  Double checked locking is a technique to prevent creating another instance of Singleton when call to getInstance() method is made in multi-threading environment. In Double checked locking pattern as shown in below example, singleton instance is checked two times before initialization. See here to learn more about double-checked-locking in Java. 

            public static Singleton getInstance(){
                if(_INSTANCE == null){
                    synchronized(Singleton.class){
                    //double checked locking - because second check of Singleton instance with lock
                            if(_INSTANCE == null){
                                _INSTANCE = new Singleton();
                            }
                        }
                    }
                return _INSTANCE;
            }
            Double checked locking should only be used when you have requirement for lazy initialization otherwise use Enum to implement singleton or simple static final variable.

7. How do you prevent for creating another instance of Singleton during serialization?
   1. You can prevent this by using **readResolve**() method, since during serialization **readObject**() is used to create instance and it return new instance every time but by using readResolve you can replace it with original Singleton instance. I have shared code on how to do it in my post Enum as Singleton in Java. This is also one of the reason I have said that use Enum to create Singleton because serialization of enum is taken care by JVM and it provides guaranteed of that
 




